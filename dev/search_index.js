var documenterSearchIndex = {"docs":
[{"location":"Rainfall/#Modelling-the-rainfall-occurrence-in-France","page":"Rainfall example","title":"Modelling the rainfall occurrence in France","text":"Let us use the SB distribution to model rain occurrence across France. The data used is extracted from the ECAD database. \n\nIt consists in daily rainfall occurrence at D=37 locations in France.\n\nusing SpatialBernoulli, Optimization,OptimizationOptimJL, Optim\nusing CSV,DataFrames\nusing Random\nimport ForwardDiff\nRandom.seed!(1234)\n","category":"section"},{"location":"Rainfall/#Getting-the-data","page":"Rainfall example","title":"Getting the data","text":"station_50Q = CSV.read(\"data/transformedECAD_stations.csv\",DataFrame);\nYobs=Matrix(CSV.read(\"data/transformedECAD_Yobs.csv\",header=false,DataFrame));\nmy_distance =Matrix(CSV.read(\"data/transformedECAD_locsdistances.csv\",header=false,DataFrame));\n\nFirst, we split the data in months. Explicit seasonality in the sense of periodic parameterisation is not treated here, see here for using this type of model in a periodic setting, or here for other parameterisations.\n\n\nmy_locations = hcat(station_50Q.LON_idx, station_50Q.LAT_idx)\nnlocs = length(my_locations[:, 1])\n\nselect_month = function (m::Int64, dates, Y::AbstractMatrix)\n    indicesm = findall(month.(dates) .== m)\n    return Y[:, indicesm]\nend\n\nusing Dates\ndate_start = Date(1973)\n\n\ndate_end = Date(2024) - Day(1)\n\nevery_year = date_start:Day(1):date_end\ndates = every_year\n\n\nYmonths = [select_month(m, every_year, Yobs) for m in 1:12];","category":"section"},{"location":"Rainfall/#Inference-for-each-month","page":"Rainfall example","title":"Inference for each month","text":"We can now estimate model parameters for each month, using the fit_mle_vfast method. The results are saved to the data folder. This is easily multi-thread-able.\n\nusing JLD2\nusing LineSearches\n\nfor imonth in 1:12\n    y = Ymonths[imonth]\n    n = length(y[1, :])\n\n\n    init_range = 600\n    init_order = 0.5\n    init_lambda = fill(0.4, nlocs)\n    init_d = SB(init_range, 1.0, init_order, init_lambda, my_distance)\n   \n    #pairwise solution\n    tdist = maximum(my_distance) / 3\n    wp = 1.0 .* (my_distance .< tdist)\n\n    @time sol_fixednu = fit_mle_vfast(init_d, y, wp;solver = Optim.LBFGS(\n    linesearch = LineSearches.BackTracking()\n)\n,  order=1/2,maxiters = 100, return_sol=false)\n\n    # Save to JLD2 file\n    save(\"data/vfastfitted_month_QMC100\" * string(imonth) * \".jld2\", Dict(\"d\" => sol_fixednu))\n    \nend","category":"section"},{"location":"Rainfall/#Visualise-the-results-:-parameters","page":"Rainfall example","title":"Visualise the results  : parameters","text":"\nvec_models_vfast = Vector{SB}(undef, 12)\nfor imonth in 1:12\n    vec_models_vfast[imonth] = load(\"data/vfastfitted_month_QMC100\" * string(imonth) * \".jld2\")[\"d\"]\nend\nntot = length(Yobs[1,:])\nusing CairoMakie\n\nfunction plot_parameters(models::Vector{SB})\n    months=1:12\nmonth_labels = [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\n                \"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"]\n    ρ = [m.range for m in models]\n    λ = hcat([m.λ for m in models]...)  # (n_sites × n_months)\n\n    fig = Figure(size = (900, 500))\n    ax1 = Axis(fig[1, 1],\n        xlabel = \"Month\",\n        ylabel = L\"\\rho\",\n        title  = L\"Estimated range parameter $\\rho$\",\n            xticks = (months, month_labels)\n\n    )\n    scatter!(ax1, months, ρ)\n    lines!(ax1, months, ρ)\n\n    ax2 = Axis(fig[1, 2],\n        xlabel = \"Month\",\n        ylabel = L\"\\lambda_s\",\n        title  = L\"Estimated rain probabilities $\\lambda_s$\",\n            xticks = (months, month_labels)\n\n    )\n    for s in 1:size(λ, 1)\n        lines!(ax2, months, λ[s, :], linewidth = 1, alpha = 0.6)\n    end\n\n    fig\nend\n\n\n\n\nplot_parameters(vec_models_vfast)\n","category":"section"},{"location":"Rainfall/#Visualise-the-results-:-comparing-simulations-to-observations","page":"Rainfall example","title":"Visualise the results  : comparing simulations to observations","text":"The goal of stochastic weather generators is to be able to simulate quickly many plausible sequences of the meteorological variables, sharing the statistical properties of the observations. \n\nAn objective of this secific model is to accurately reproduce large-scale spatial events, such as widespread dry or wet days. We define the ROR indicator as     ROR(n) = \\frac{1}{D}\\sum_{s=1}^D Y_s^{(n)} A low (high) value of ROR(n) denotes a dry (wet) day for many locations at the same time. \n\nThe distribution in the observations is compared to the distribution evaluated from many simulations, as well as the autocorrelation of this indicator, for each season.\n\nUnsuprisingly, there is a clear lack of temporal dependance when using a simple SpatialBernoulli, suggesting the need for a structured model (such as HMMs! ). However, the distribution of the indicator itself is not that far off.\n\nNb = 10\nD = 37\nusing StatsBase\nusing LinearAlgebra, NaNMath\n\nbegin\n    Ysvf = zeros(Bool, nlocs, ntot, Nb)\n    @time \"Simulations  Y\" for i in 1:Nb\n        for t in 1:ntot\n        m = month(every_year[t])\n        Ysvf[:, t, i] = rand(vec_models_vfast[m]);\n        end\n    end\nend\n\nRRmax = 0\nRORo = [mean(r .> RRmax) for r in eachcol(Yobs)]\nRORs = [[mean(r .> RRmax) for r in eachcol(rr)] for rr in eachslice(Ysvf, dims=3)]\n\nmaxlag = 10\n\ninclude(\"assets/utilities.jl\")\nbegin\n    # Makie ROR distribution and autocorrelation (2×4 grid)\nJJA = [6, 7, 8]\nMAM = [3, 4, 5]\nSON = [9, 10, 11]\nDJF = [12, 1, 2]\nSEASONS = [DJF, MAM, JJA, SON]\nseasonname = [\"DJF\", \"MAM\", \"JJA\", \"SON\"]\nidx_seasons = [findall(month.(every_year) .∈ tuple(season)) for season in SEASONS]\n    fig_ROR = Figure(fontsize=19)\n    wwww = 200\n    hhhh = 150\n    # Row 1: Distribution plots\n    for m in eachindex(idx_seasons)\n        row = 1\n        col = m\n\n        # Distribution subplot\n        ax_dist = Axis(fig_ROR[row, col],\n            xlabel=\"ROR\",\n            ylabel=col == 1 ? \"Distribution\" : \"\",\n            title=seasonname[m],\n            width=wwww,\n            height=hhhh)\n        xax = 0:(1/D):1.0\n        xaxbin = vcat(xax, [1.01])\n        errorlinehist!(ax_dist, [RORs[i][idx_seasons[m]] for i in 1:Nb];\n            label=\"\",\n            color=:gray,\n            secondarycolor=:gray, normalization=:probability,\n            bins=xaxbin,\n            errortype=:percentile,\n            percentiles=[0, 100],\n            alpha=0.5,\n            secondaryalpha=0.2,\n            centertype=:median)\n      scatter!(ax_dist, xax, [mean(RORo[idx_seasons[m]] .== x) for x in xax], color=:blue, markersize=6, label=m == 1 ? \"Observations\" : nothing)\n\n        ylims!(ax_dist, 0, 0.06)\n        col > 1 && hideydecorations!(ax_dist, grid=false)\n\n        # Autocorrelation subplot\n        row = 2\n        ax_acf = Axis(fig_ROR[row, col],\n            xlabel=\"Lag\",\n            ylabel=col == 1 ? \"ACF\" : \"\",\n            width=wwww,\n            height=hhhh,\n        )\n\n        rorsim = [RORs[i][idx_seasons[m]] for i in 1:Nb]\n        acf_sim = [autocor(rorsim[i], 0:maxlag) for i in 1:length(rorsim)]\n        errorline!(ax_acf, 0:maxlag, stack(acf_sim, dims=1)',\n            color=:gray,\n            secondarycolor=:gray,\n            errortype=:percentile,\n            percentiles=[0, 100],\n            secondaryalpha=0.2,\n            centertype=:median)\n    \n        # Observations\n        acf_obs = autocor(RORo, 0:maxlag)\n        scatter!(ax_acf, 0:maxlag, acf_obs, color=:blue, markersize=7)\n        col > 1 && hideydecorations!(ax_acf, grid=false)\n    end\n \n    Legend(\n    fig_ROR[:, 5],\n    [\n        [LineElement(color=:gray), PolyElement(color=:gray, alpha=0.2)],\n\n        MarkerElement(color=:blue, marker=:circle, markersize=8)\n    ],\n    [\n        \"SB\",\n        \"Observations\"\n    ]\n)\n\n    resize_to_layout!(fig_ROR)\n    fig_ROR\nend","category":"section"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"Documentation for SpatialBernoulli.\n\n","category":"section"},{"location":"functions/#SpatialBernoulli.SB","page":"Functions","title":"SpatialBernoulli.SB","text":"SB{TR<:Real, TS<:Real, TO<:Real, AV<:AbstractVector, AM<:AbstractMatrix, AAM<:AbstractMatrix}\n\nDefines a discrete multivariate distribution SB using a latent Gaussian process. \n\nFor now, the latent covarience matrix is definied by the parameters of a Matern covariance function :\n\nC(h) = σ² * 2^(1-ν) / Γ(ν) * (sqrt(2*ν) * h / ρ)^ν * K_ν(sqrt(2*ν) * h / ρ)\n\nThe marginal Bernoulli probabilities are given by λ.\n\nArguments\n\nrange::Real : Value of ρ, rate of decay. Represents the spatial scale of the process.\nsill::Real: Value of variance σ² - values different than 1 are deprecated.\norder::Real : Value of ν, shape of the Matérn covariance function; recall that a value of 0.5 is the exponential covariance function.\nλ::AbstractVector : Vector of marginal rain probabilities. Expected to be of length D the number of spatial components.\nh::AbstractMatrix : Matrix of distances between all spatial locations. Expected size D*D.\nΣU::AbstractMatrix : Covariance matrix contructed from the covariance function and distance matrix.\n\nReturns\n\nSB(range,sill,order,λ,h,ΣU)\n\nTODO : make a structure SB(covfun(θ...), h, ΣU) instead for more flexibility where.\n\n\n\n\n\n","category":"type"},{"location":"functions/#SpatialBernoulli.SB-NTuple{5, Any}","page":"Functions","title":"SpatialBernoulli.SB","text":"SB(range, sill, order, λ, h)\n\nConstructor for a discrete multivariate distribution SB. The constructor uses the distance matrix to compute the covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Distributions.fit_mle-Tuple{SB, AbstractArray{<:Real}}","page":"Functions","title":"Distributions.fit_mle","text":"fit_mle(d::SB, Y::AbstractArray{<:Real}[,wp::AbstractMatrix{<:Real}, w::AbstractVector{<:Real}];  solver, m = 1000*length(d), return_sol = false, solkwargs...)\n\nReturn the (weighted) MLE for the distribution d::SB. \n\nsolver choice of solver\nsolkwargs any keywords arguments that can be put inside the solve functions e.g. fit_mle(d, Y; maxiters = 2)\nw not necessary, used for using weighted loglikelihood instead of loglikelihood\nwp not technically  necessary, used for using pairwise loglikelihood instead of true loglikelihood. \n\n\n\n\n\n","category":"method"},{"location":"functions/#Distributions.logpdf-Tuple{SB, AbstractVector{<:Real}}","page":"Functions","title":"Distributions.logpdf","text":"logpdf(d::SB, y::AbstractVector{<:Real}[, wp::AbstractMatrix{<:Real}]; m=length(d) * 100, return_error=false,,a=zeros(length(d)), b=zeros(length(d)), finite_bounds=zeros(length(d)),   zerosvec=fill(0, length(d)))\n- Computes logpdf(d,y) with model d.\n- If argument `wp` is used, pairwise log-likelihood is used instead of full log-likelihood, with weights matrix `wp`.\n- `a`, `b` , `finite_bounds`, `zerosvec` preallocations can only be used for full log-likelihood, as well as `return_error`.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Distributions.pdf-Tuple{SB, AbstractVector{<:Real}}","page":"Functions","title":"Distributions.pdf","text":"pdf(d::SB, y::AbstractVector{<:Real}; m=length(d) * 100, return_error=false,a=zeros(length(d)), b=zeros(length(d)), finite_bounds=zeros(length(d)),   zerosvec=fill(0, length(d)))\n\nComputes pdf(d::SB, y).\n\nIt is recommended by MvNormalCDF.jl to use m= length(d)100. Using m=length(d)100 can be a good starting point. \n\nPossible uses :\n\npdf(d,y::AbstractVector{<:Real})\npdf(d,y,m=3000) ... etc\n\nArguments\n\nd::SB  : Spatial Bernoulli model\ny::AbstractVector{<:Real} : one realisation of the model.\n\nArguments that have a default value\n\nm::Int: number of samples in QMC computation\nreturn_error::Bool : Should the error of QMC computation be given, or not ?\na, b , finite_bounds, zerosvec : pre-allocated vectors for the integral boundaries. When using n times the pdf function, it allows one single reused allocation instead of n allocations.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Random.rand!-Union{Tuple{T}, Tuple{Random.AbstractRNG, SB, AbstractVector{T}}} where T<:Real","page":"Functions","title":"Random.rand!","text":"rand!(rng::AbstractRNG, d::SB, x::AbstractVector{T})\n\nDefinition of random sampling of d::SB. As SB <: MultivariateDistribution, Distributions.jl provides a generic fallback for other  rand calls.\n\nPossible uses\n\nIn-place sampling rand!(rng::AbstractRNG, d::SB, x::AbstractVector{T}) where x is pre-allocated and the random generator is fixed\nIn-place sampling rand!(d::SB, x::AbstractVector{T}) where x is pre-allocated\nSampling x= rand(rng::AbstractRNG, d::SB) where the random generator is fixed\nSampling x= rand( d::SB)\nSampling x= rand( d::SB, n::Int) for n realisations.\nSampling x= rand(rng::AbstractRNG, d::SB, n::Int) for n realisations.\n\n\n\n\n\n","category":"method"},{"location":"functions/#SpatialBernoulli.expkernel-Tuple{Any}","page":"Functions","title":"SpatialBernoulli.expkernel","text":"expkernel(h;range,sill)\n\nRedefines the exponential kernel C(h) = σ²exp(-h/ρ)\n\nArguments\n\nh::AbstractMatrix or h::Real: Values of distance at which the covariance must be computed.\nrange::Real : Value of ρ, rate of decay. Represents the spatial scale of the process.\nsill::Real: Value of variance σ² \n\n\n\n\n\n","category":"method"},{"location":"functions/#SpatialBernoulli.fit_mle_vfast-Tuple{SB, AbstractArray{<:Real}, AbstractMatrix{<:Real}}","page":"Functions","title":"SpatialBernoulli.fit_mle_vfast","text":"fit_mle_vfast(d::SB, Y::AbstractArray{<:Real}[,wp::AbstractMatrix{<:Real}, w::AbstractVector{<:Real}];  solver, return_sol = false, solkwargs...)\n\nReturn the (weighted) MLE for the distribution d::SB using the very fast approximation.\n\n\n\n\n\n","category":"method"},{"location":"functions/#SpatialBernoulli.loglikelihood_vfast-Tuple{SB, AbstractArray{<:Real}, AbstractMatrix{<:Real}}","page":"Functions","title":"SpatialBernoulli.loglikelihood_vfast","text":"loglikelihood_vfast(d::SB, Y::AbstractArray{<:Real}[, wp::AbstractMatrix{<:Real}, w::AbstractVector{<:Real}])\n\nComputes the pairwise (possibly weighted) loglikelihood using the approximation of [Tsay (2023)](https://doi.org/10.1080/03610918.2021.1884718)\n\nw not necessary, used for using weighted loglikelihood instead of loglikelihood.\nwp is necessary, used for using pairwise loglikelihood. \n\nArguments\n\nd::SB\nY :: AbstractArray{<:Real} with length(d) lines, each column is a realization of d. \nw::AbstractVector{<:Real} is an optional vector of weights to compute weighted log-likelihood as sum(w_i llh(yi)), used in EM algorithms for example.  \nwp::AbstractMatrix{<:Real}: weights matrix \n\n\n\n\n\n","category":"method"},{"location":"functions/#SpatialBernoulli.matern-Tuple{Any}","page":"Functions","title":"SpatialBernoulli.matern","text":"matern(h; range, sill, order)\n\nRedefines the Matern covariance kernel to ensure the use of the BesselK.jl package.\n\nArguments\n\nh::AbstractMatrix or h::Real: Values of distance at which the covariance must be computed.\nrange::Real : Value of ρ, rate of decay. Represents the spatial scale of the process.\nsill::Real: Value of variance σ² \norder::Real : Value of ν, shape of the Matérn covariance function\n\n\n\n\n\n","category":"method"},{"location":"functions/#SpatialBernoulli.norm_cdf_2d_vfast-Tuple{Any, Any, Any}","page":"Functions","title":"SpatialBernoulli.norm_cdf_2d_vfast","text":" norm_cdf_2d_vfast(x₁, x₂, ρ)\n\nComputes the bivariate standard normal cumulative distribution function (CDF) Φ₂(x₁, x₂, ρ) ,\n\nwhere   (X₁,X₂) ~ N(0, [ 1   ρ       ρ   1 ])\n\nArguments\n\nx₁::Real\nx₂::Real\nρ::Real : correlation value between -1 and 1\n\nReturns\n\nΦ₂(x₁, x₂, ρ) = P(X₁<x₁,X₂<x₂)\n\nSource\n\nConverted from https://github.com/david-cortes/approxcdf https://github.com/david-cortes/approxcdf/blob/master/src/other.cpp\n\n\n\n\n\n","category":"method"},{"location":"functions/#StatsAPI.loglikelihood-Tuple{SB, AbstractArray{<:Real}}","page":"Functions","title":"StatsAPI.loglikelihood","text":"loglikelihood(d::SB, Y::AbstractArray{<:Real}[, wp::AbstractMatrix{<:Real}, w::AbstractVector{<:Real}]; m=length(d) * 500)\n\nComputes the (possibly pairwise) (possibly weighted) loglikelihood\n\nw not necessary, used for using weighted loglikelihood instead of loglikelihood.\nwp not technically  necessary, used for using pairwise loglikelihood instead of true loglikelihood. \n\nArguments\n\nd::SB\nY :: AbstractArray{<:Real} with length(d) lines, each column is a realization of d. \nm::Int: number of samples in QMC computation\nw::AbstractVector{<:Real} is an optional vector of weights to compute weighted log-likelihood as sum(w_i llh(yi)), used in EM algorithms for example.  \nwp::AbstractMatrix{<:Real}: weights matrix in the pairwise case.\n\n\n\n\n\n","category":"method"},{"location":"#SpatialBernoulli-package","page":"Home","title":"SpatialBernoulli package","text":"SpatialBernoulli.jl is a package to define a spatially correlated Bernoulli variable Y using a latent Gaussian construction.","category":"section"},{"location":"#Model","page":"Home","title":"Model","text":"The Spatial Bernoulli model is defined as follows:\n\nY ~ SB(C_Y, λ)\n(X_{Y,1}, …, X_{Y,D}) ~ N(0, C_Y)\nFor all spatial locations s:\nY_s = 1 if X_{Y,s} ≤ Φ⁻¹(λ_s)\nY_s = 0 otherwise\n\nHere:\n\nC_Y is the covariance matrix of the latent Gaussian field\nλ = (λ_s)_{s=1,…,D} is the vector of marginal probabilities\nΦ denotes the cumulative distribution function (CDF) of the standard normal distribution\n\nThis model is used in the paper to be inserted later to model precipitation occurrence across a large region.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"The package provides several methods, including:\n\nModel definition\nProbability density functions (pdf) and their logarithm (logpdf), computed using bivariate Gaussian integrals with   MvNormalCDF.jl\nMaximum likelihood estimation (not recommended for high-dimensional samples)\nMaximum pairwise likelihood estimation with bivariate integrals computed using   MvNormalCDF.jl\nFast maximum pairwise likelihood estimation with bivariate integrals computed using the approximation of   Tsay (2023)","category":"section"},{"location":"#Example","page":"Home","title":"Example","text":"The documentation also provides a simulated example.\n\nBelow are examples of generation from the Spatial Bernoulli model with:\n\na constant marginal probability λ in space, and\nan exponential covariance function   C_Y(h) = exp(-h / ρ)\n\n(Image: Model illustration)","category":"section"},{"location":"example/#Example","page":"Example","title":"Example","text":"using SpatialBernoulli, Optimization,OptimizationOptimJL, Optim\nusing LineSearches\nusing Random\nimport ForwardDiff\nrng = MersenneTwister(1234)","category":"section"},{"location":"example/#Parameters","page":"Example","title":"Parameters","text":"\n\n\n# define locations in the unit square\nmy_locations = vcat(([x y] for x in 0:0.2:1 for y in 0:0.2:1)...)\nnlocs = length(my_locations[:, 1])\n\n\nmy_distance = [sqrt(sum(abs2, my_locations[i, :] - my_locations[j, :])) for i in axes(my_locations, 1), j in axes(my_locations, 1)]\n\n# randomly generate a SpatialBernoulli\nmy_λ = rand(nlocs)# [0.5+ 0.1*i for i in 1:nlocs] \nmy_range = 0.3\nmy_sill = 1.0\nmy_order = 1 / 2\n","category":"section"},{"location":"example/#Create-the-distribution","page":"Example","title":"Create the distribution","text":"d = SB(my_range, my_sill, my_order, my_λ, my_distance)\n\nuse it like any Distributions.jl distribution","category":"section"},{"location":"example/#Random-draws","page":"Example","title":"Random draws","text":"\nn = 2000\ny=rand(rng,d,n)\n\nusing CairoMakie\nyplot=y[:,2]\nbegin\nfig = Figure()\nax = Axis(fig[1, 1])\n\nscatter!(\n    ax,\n    my_locations[yplot .== 0, 1],\n    my_locations[yplot .== 0, 2];\n    color = :black,\n    label = \"y = 0\"\n)\n\nscatter!(\n    ax,\n    my_locations[yplot .== 1, 1],\n    my_locations[yplot .== 1, 2];\n    color = :white,\n    strokecolor = :black,\n    label = \"y = 1\"\n)\n\naxislegend(ax)\nfig\nend","category":"section"},{"location":"example/#Fitting","page":"Example","title":"Fitting","text":"init_range = 0.5\ninit_order = 0.5\ninit_lambda = fill(0.4, nlocs)\ninit_d = SB(init_range, 1.0, init_order, init_lambda, my_distance)\n\ntdist = maximum(my_distance) / 1\nwp = 1.0 .* (my_distance .< tdist)\n\n@timed sol3 = fit_mle_vfast(init_d, y, wp; solver = Optim.LBFGS(\n    linesearch = LineSearches.BackTracking()\n), order=my_order, return_sol=true, maxiters = 2000)\n","category":"section"}]
}
